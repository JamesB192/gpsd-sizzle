# packet.py - recognize GPS packet types
# This code is generated by scons.  Do not hand-hack it!
#
# This file is Copyright 2019 by the GPSD project
# SPDX-License-Identifier: BSD-2-Clause
#
# This code runs compatibly under Python 2 and 3.x for x >= 2.
# Preserve this property!
#
# -*- coding: utf-8 -*-
"""Recognize GPS packets using the lexer from libgpsd and ctypes.

The new() function returns a new packet-lexer instance.  Lexer instances
have two methods:
    get() takes a file handle argument and returns a tuple consisting of
the integer packet type and string packet value.  At the end of the stream
it returns (-1, "").
    reset() resets the packet-lexer to its initial state.
    The module also has a register_report() function that accepts a callback
for debug message reporting.  The callback will get two arguments: the error
level of the message; and the message itself.
"""
from __future__ import absolute_import, print_function
import json
import os
import re
import struct
import sys
from . import misc

INVALID_PACKET = -1
COMMENT_PACKET = 0
NMEA_PACKET = 1
AIVDM_PACKET = 2
GARMINTXT_PACKET = 3
SIRF_PACKET = 4
ZODIAC_PACKET = 5
TSIP_PACKET = 6
EVERMORE_PACKET = 7
ITALK_PACKET = 8
GARMIN_PACKET = 9
NAVCOM_PACKET = 10
UBX_PACKET = 11
SUPERSTAR2_PACKET = 12
ONCORE_PACKET = 13
GEOSTAR_PACKET = 14
NMEA2000_PACKET = 15
GREIS_PACKET = 16
SKY_PACKET = 17
ALLYSTAR_PACKET = 18
MAX_GPSPACKET_TYPE = 18
RTCM2_PACKET = 19
RTCM3_PACKET = 20
JSON_PACKET = 21
PACKET_TYPES = 21
LOG_SHOUT = 0
LOG_WARN = 1
LOG_CLIENT = 2
LOG_INF = 3
LOG_PROG = 4
LOG_IO = 5
LOG_DATA = 6
LOG_SPIN = 7
LOG_RAW = 8
LOG_RAW1 = 9
LOG_RAW2 = 10
ISGPS_ERRLEVEL_BASE = LOG_RAW

loghook = None
prep = lambda x: print(repr(x), file=sys.stderr)


def register_report(reporter):
    """register_report(callback)

    The callback must be a callable object expecting a string parameter.
    """
    global loghook
    if not callable(reporter):
        raise TypeError("Not callable")
    loghook = reporter


def new():
    """new() -> new packet-self object"""
    return Lexer()


class Lexer(object):
    """GPS packet lexer object

    Fetch a single packet from a file handle."""

    ibuf = ""
    ibufptr = 0
    sbufptr = 0
    eof = False
    lextable = [
        [r"\A([\r\n]+)", "nl"],
        [r"\A(#.*[\r\n]+)", "comment"],
        [r"\A(\{.*\}[\r\n]+)", "json"],
        [r"\A(\$.+\*..[\r\n]+)", "nmea"],
        [r"\A(\!.+\*..[\r\n]+)", "aivdm"],
        [r"\A(\xa0\xa2.+\xb0\xb3)", "sirf"],
        
        [r"\A(\x10.*\x10\x03)", "tsip"],
        [r"\A(\xff\x81.*)", "zodiac"],
        [r"\A(\xb5b.*)", "ubx"],
        [r"\A(\$STI,.+[\r\n]+)", "nmea_nosig"],
        [
            r"\A(\*[0-9]{12}[NS][0-9]{7}[EW][0-9]{8}[sDgGS_][0-9]{3}[\+-]"
            "[0-9]{5}[EW][0-9]{4}[NS][0-9]{4}[UD][0-9]{4}[\r\n]+)",
            "garmintxt",
        ],
    ]

    def __init__(self):
        self.reset()

    def reset(self):
        """Reset the lexer to ground state."""
        self.ibuf = ""
        self.ibufptr = 0
        self.sbufptr = 0
        self.eof = False

    def get(self, file_handle, nest=False):
        """Get a packet from the file handle."""
        red_buffer = os.read(file_handle, 128)
        self.eof = bool(0 == len(red_buffer))
        self.ibuf += misc.polystr(red_buffer)
        tbuf = self.ibuf
        if not nest:
            ret = self.packet_parse()
            if ret:
                return ret
            if self.eof and not self.ibuf:
                return [0, INVALID_PACKET, b"", self.sbufptr]
        else:
            ret = []
            while True:
                ret2 = self.packet_parse()
                if ret2:
                    ret.append(ret2)
                elif ret:
                    return ret
                else:
                    break
            if self.eof and not self.ibuf:
                return [0, INVALID_PACKET, b"", self.sbufptr]
        self.ibuf = tbuf
        self.ibufptr = 0
        ret = [
            len(self.ibuf),
            INVALID_PACKET,
            misc.polybytes(self.ibuf),
            self.sbufptr,
        ]
        return [ret] if nest else ret

    def packet_parse(self):
        for self.ibufptr in range(len(self.ibuf)):
            # prep([self.ibufptr, self.ibuf])
            scratch = self.ibuf[self.ibufptr :]
            ret = self.next_state(scratch)
            if ret:
                return ret
        return None

    def next_state(self, scratch):
        for row in self.lextable:
            pats = re.match(row[0], scratch)
            if not pats:
                continue
            hook = getattr(self, "bless_" + row[1])
            mid = hook(len(pats.group(1)), scratch)
            if mid is None:
                continue
            return mid
        return None

    def bless_nmea_nosig(self, length, _):
        return self.accept_bless(length, NMEA_PACKET)

    def bless_garmintxt(self, length, _):
        return self.accept_bless(length, GARMINTXT_PACKET)

    def bless_nmea(self, length, scratch):
        xor = 0
        nmea = scratch[:length].rstrip()
        for byte in nmea[1:-3]:
            xor ^= ord(byte)
        if nmea[-2:].lower() == "%02x" % xor:
            return self.accept_bless(length, NMEA_PACKET)
        return None

    def bless_comment(self, length, scratch):
        """
        pushback = self.ibuf
        for check in "{$!\xb5":
            if check in scratch:
                pointer = scratch.index(check)
                if self.next_state(scratch[pointer:]):
                    self.pushback(pushback)
                    return self.accept_bless(pointer - 1, COMMENT_PACKET)
        """
        return self.accept_bless(length, COMMENT_PACKET)
        # return self.reject_bless(length)
    
    def bless_json(self, length, scratch):
        try:
            _ = json.loads(scratch.rstrip("\r\n"))
            return self.accept_bless(length, JSON_PACKET)
        except json.JSONDecodeError:
            return self.reject_bless(length)

    def bless_nl(self, length, _):
        return self.reject_bless(length)

    def bless_aivdm(self, length, scratch):
        xor = 0
        nmea = scratch[:length].rstrip()
        for byte in nmea[1:-3]:
            xor ^= ord(byte)
        if nmea[-2:].lower() == "%02x" % xor:
            return self.accept_bless(length, AIVDM_PACKET)
        return self.reject_bless(length)

    def bless_sirf(self, _, scratch):
        length = (
            struct.unpack("<H", misc.polybytes(scratch[2:4]))[0] + 8
        )
        frag = scratch[:length]
        csum = 0
        for char in frag[3:-4]:
            csum += ord(char)
        csump = struct.unpack("<H", misc.polybytes(scratch[-4:-2]))[0]
        if csump != csum:
            return self.reject_bless(length)
        return self.accept_bless(length, SIRF_PACKET)

    def bless_zodiac(self, _length, scratch):
        header = struct.unpack("<HHHHH", misc.polybytes(scratch[:10]))
        if 0 != sum(header) % (1 << 16):
            prep([sum(header) % (1 << 16), header])
            return self.reject_bless(_length)
        length = header[2] * 2
        if 10 == length:  # seems to never happen
            return self.accept_bless(length + 4, ZODIAC_PACKET)
        words = [
            struct.unpack("<H", misc.polybytes(scratch[x + 10 : x + 12]))[0]
            for x in range(length + 2, 2)
        ]
        if 0 != sum(words) % (1 << 16):
            prep([sum(words) % (1 << 16), words])
            return self.reject_bless(length)
        return self.accept_bless(length + 12, ZODIAC_PACKET)

    def unbless_tsip(self, length, _):
        return self.accept_bless(length, TSIP_PACKET)

    def bless_ubx(self, length_, scratch):
        prep(scratch)
        length = (
            struct.unpack("<H", misc.polybytes(scratch[4:6]))[0] + 8
        )
        if length_ != length:
            prep([length_, length])
        frag = scratch[:length]
        a = b = 0
        for char in frag[2:-2]:
            a += ord(char)
            b += a
            a &= 255
            b &= 255
        prep(
            [
                [a, b],
                [ord(frag[-4]), ord(frag[-3])],
                length,
                "".join("%02x" % ord(x) for x in frag),
            ]
        )
        if frag[-2:] == "%c%c" % (a, b):
            return self.accept_bless(length, UBX_PACKET)
        return None

    def accept_bless(self, length, typed):
        self.sbufptr += (
            length + self.ibufptr
        )  # dang gpscat takes counter - length
        ret = [
            length,
            typed,
            misc.polybytes(self.ibuf[self.ibufptr :][:length]),
            self.sbufptr,
        ]
        self.ibuf = self.ibuf[length + self.ibufptr :]
        self.ibufptr = 0
        return ret

    def reject_bless(self, length):
        self.sbufptr += (
            length + self.ibufptr
        )  # dang gpscat takes counter - length
        self.ibuf = self.ibuf[length + self.ibufptr :]
        self.ibufptr = 0
        return None
